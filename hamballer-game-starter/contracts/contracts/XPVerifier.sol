// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title XPVerifier
 * @dev Verifies zero-knowledge proofs for XP badge claims and prevents replay
 *      attacks by tracking used nullifier hashes. The actual verification logic
 *      is delegated to an external Verifier contract generated by snarkjs or
 *      Noir tooling.
 */
interface IProofVerifier {
    function verify(bytes calldata proof) external view returns (bool);
}

contract XPVerifier {
    IProofVerifier public verifier;

    // Track used nullifier hashes to prevent replaying claims
    mapping(bytes32 => bool) public nullifierUsed;

    event ProofVerificationFailed(address claimant);

    constructor(address verifierAddress) {
        verifier = IProofVerifier(verifierAddress);
    }

    /**
     * @notice Verify a ZK proof and store its nullifier so it cannot be reused.
     * @param claimId Unique claim identifier provided by the user.
     * @param proof   ZK proof bytes generated off-chain.
     */
    function verifyAndStoreClaim(uint256 claimId, bytes calldata proof) external returns (bool) {
        bytes32 nullifier = keccak256(abi.encodePacked(claimId, msg.sender));
        require(!nullifierUsed[nullifier], "XPVerifier: claim already used");

        bool valid = verifier.verify(proof);
        if (!valid) {
            emit ProofVerificationFailed(msg.sender);
            return false;
        }

        nullifierUsed[nullifier] = true;
        return true;
    }
}

